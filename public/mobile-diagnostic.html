<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mobile Diagnostic</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      padding: 20px;
      max-width: 600px;
      margin: 0 auto;
      font-size: 14px;
    }
    .status {
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    .ok { background: #d4edda; border-color: #c3e6cb; }
    .warn { background: #fff3cd; border-color: #ffeaa7; }
    .error { background: #f8d7da; border-color: #f5c6cb; }
    button {
      padding: 10px 20px;
      margin: 5px;
      border: none;
      border-radius: 5px;
      background: #007bff;
      color: white;
      font-size: 14px;
    }
    pre {
      background: #f5f5f5;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
      font-size: 12px;
    }
    h3 { margin-top: 20px; }
  </style>
</head>
<body>
  <h1>üì± Mobile Diagnostic</h1>
  
  <div id="results"></div>
  
  <div style="margin-top: 20px;">
    <button onclick="runDiagnostic()">üîç Run Diagnostic</button>
    <button onclick="clearAll()">üóëÔ∏è Clear All Data</button>
    <button onclick="location.href='/'">üè† Go to App</button>
  </div>

  <script>
    async function runDiagnostic() {
      const results = document.getElementById('results');
      results.innerHTML = '<p>Running diagnostic...</p>';
      
      const report = [];
      
      // 1. Device info
      report.push('<h3>Device Info</h3>');
      report.push(`<div class="status ok">
        User Agent: ${navigator.userAgent}<br>
        Online: ${navigator.onLine ? '‚úÖ' : '‚ùå'}<br>
        Screen: ${window.innerWidth}x${window.innerHeight}
      </div>`);
      
      // 2. Service Worker
      report.push('<h3>Service Worker</h3>');
      if ('serviceWorker' in navigator) {
        const regs = await navigator.serviceWorker.getRegistrations();
        if (regs.length > 0) {
          report.push(`<div class="status ok">‚úÖ ${regs.length} registration(s)</div>`);
          regs.forEach((r, i) => {
            report.push(`<div class="status">
              <strong>SW ${i + 1}:</strong><br>
              State: ${r.active ? '‚úÖ Active' : r.installing ? '‚è≥ Installing' : '‚ùå Not active'}<br>
              Scope: ${r.scope}
            </div>`);
          });
        } else {
          report.push('<div class="status error">‚ùå No service worker registered</div>');
        }
      } else {
        report.push('<div class="status error">‚ùå Service Worker not supported</div>');
      }
      
      // 3. Cache Storage
      report.push('<h3>Cache Storage</h3>');
      if ('caches' in window) {
        const cacheNames = await caches.keys();
        if (cacheNames.length > 0) {
          report.push(`<div class="status ok">‚úÖ ${cacheNames.length} cache(s) found</div>`);
          for (const name of cacheNames) {
            const cache = await caches.open(name);
            const keys = await cache.keys();
            report.push(`<div class="status">
              <strong>${name}</strong>: ${keys.length} items<br>
              ${keys.slice(0, 3).map(k => `<small>${k.url.split('/').pop()}</small>`).join('<br>')}
              ${keys.length > 3 ? `<br><small>...and ${keys.length - 3} more</small>` : ''}
            </div>`);
          }
        } else {
          report.push('<div class="status warn">‚ö†Ô∏è Cache is EMPTY (normal on first load)</div>');
        }
      } else {
        report.push('<div class="status error">‚ùå Cache API not supported</div>');
      }
      
      // 4. LocalStorage
      report.push('<h3>LocalStorage</h3>');
      const lsKeys = Object.keys(localStorage);
      if (lsKeys.length > 0) {
        report.push(`<div class="status ok">‚úÖ ${lsKeys.length} item(s)</div>`);
        lsKeys.forEach(key => {
          const value = localStorage.getItem(key);
          const size = new Blob([value]).size;
          report.push(`<div class="status">
            <strong>${key}</strong><br>
            Size: ${(size / 1024).toFixed(2)} KB
          </div>`);
        });
      } else {
        report.push('<div class="status warn">‚ö†Ô∏è LocalStorage is empty</div>');
      }
      
      // 5. Appwrite connectivity
      report.push('<h3>Appwrite Connection</h3>');
      try {
        const response = await fetch('https://sfo.cloud.appwrite.io/v1/health', {
          method: 'GET',
          signal: AbortSignal.timeout(5000)
        });
        if (response.ok) {
          report.push('<div class="status ok">‚úÖ Appwrite reachable</div>');
        } else {
          report.push(`<div class="status warn">‚ö†Ô∏è Appwrite responded: ${response.status}</div>`);
        }
      } catch (e) {
        report.push(`<div class="status error">‚ùå Cannot reach Appwrite: ${e.message}</div>`);
      }
      
      results.innerHTML = report.join('');
    }
    
    async function clearAll() {
      if (!confirm('Clear all cache, localStorage, and service workers?')) return;
      
      // Clear caches
      const cacheNames = await caches.keys();
      await Promise.all(cacheNames.map(n => caches.delete(n)));
      
      // Unregister SWs
      const regs = await navigator.serviceWorker.getRegistrations();
      await Promise.all(regs.map(r => r.unregister()));
      
      // Clear localStorage
      localStorage.clear();
      
      alert('‚úÖ All cleared! Reload the page.');
    }
    
    // Auto-run on load
    runDiagnostic();
  </script>
</body>
</html>
